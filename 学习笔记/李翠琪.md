**github：**
```
1.	已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中
2.	Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。
3.	工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。
4.	暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域
5.	因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些特性分支合并入其他分支中。
6.	许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。 他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了。 这样，在确保这些已完成的特性分支（短期分支，比如之前的 iss53 分支）能够通过所有测试，并且不会引入更多 bug 之后，就可以合并入主干分支中，等待下一次的发布。
7.	事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前。
8.	集中式工作流，这意味着如果两个开发者从中心仓库克隆代码下来，同时作了一些修改，那么只有第一个开发者可以顺利地把数据推送回共享服务器。 第二个开发者在推送修改之前，必须先将第一个人的工作合并进来，这样才不会覆盖第一个人的修改。 这和 Subversion （或任何 CVCS）中的概念一样，而且这个模式也可以很好地运用到 Git 中。
9.	如果在公司或者团队中，你已经习惯了使用这种集中式工作流程，完全可以继续采用这种简单的模式。 只需要搭建好一个中心仓库，并给开发团队中的每个人推送数据的权限，就可以开展工作了。Git 不会让用户覆盖彼此的修改。 例如 John 和 Jessica 同时开始工作。 John 完成了他的修改并推送到服务器。 接着 Jessica 尝试提交她自己的修改，却遭到服务器拒绝。 她被告知她的修改正通过非快进式（non-fast-forward）的方式推送，只有将数据抓取下来并且合并后方能推送。 这种模式的工作流程的使用非常广泛，因为大多数人对其很熟悉也很习惯。
10.	当然这并不局限于小团队。 利用 Git 的分支模型，通过同时在多个分支上工作的方式，即使是上百人的开发团队也可以很好地在单个项目上协作：
	(1).	项目维护者推送到主仓库。
	(2).	贡献者克隆此仓库，做出修改。
	(3).	贡献者将数据推送到自己的公开仓库。
	(4).	贡献者给维护者发送邮件，请求拉取自己的更新。
	(5).	维护者在自己本地的仓库中，将贡献者的仓库加为远程仓库并合并修改。
	(6).	维护者将合并后的修改推送到主仓库
```


**cocos2d-x：**
```
学习资料：
	书籍PDF：cocos2d-x实战 C++卷
	上一届的泡泡堂项目：https://github.com/Moonlor/SQLS
	cocos2d-x官方API：https://docs.cocos2d-x.org/api-ref/cplusplus/v3x/modules.html
	cocos2d-x用户手册：https://docs.cocos.com/cocos2d-x/manual/zh/
	cocos2d-x视频（较新，较简短）：https://www.bilibili.com/video/av10560332
	cocos2d-x视频（较老，较啰嗦）：https://www.bilibili.com/video/av16632457
	图书馆借阅书籍：cocos2d-x 3.x 游戏案例开发大全
新建项目：
	cmd进入目录 E:\c++big programe\cocos2d-x-3.17.1\tools\cocos2d-console\bin
	cocos new test2 -p com.hfy.mygame -l cpp -d E:\MyGame
	在E:\test\test1\proj.win32中打开
		
	图片存放位置: E:\MyGame\test1\proj.win32\Debug.win32\Resources
	自定义类要放在E:\MyGame\test1\Classes
	可以用flash制作动画,在cocos里面播放
	内存管理机制:计数引用,This->addChild()引用计数会加一,且节点最后addChild()里面的会释放一次,只要保证最后的引用计数为1就行,它会自动释放掉
	缓存管理机制,精灵需要添加图片的情况下,可以重复使用(小兵),它有纹理缓存机制
	图片拼接,节省内存
	例子编辑器来弄粒子,攻击特效
	导演用堆栈切换场景，可以先push一个场景，用完再pop，实现场景切换（如设置音效再返回主界面）
	网格特效，是对一个区域内部产生的动画
	地图编辑器 mapeditor
	地图过大时，设置位置达到让地图移动的效果，到地图边界时，就不移动
	碰撞检测，第一层地板可以走，第二层设置障碍物不可以走
	在cocos里面找到它的演示
	背景音乐，音效
	弱联网游戏或者实时联网，可能用实时联网
	particle designer粒子设置工具 生成的是plist文件
	data文件可能是存放一些数据的，xml
	tmx也是一种xml文件
	用Nuget管理额外的库，如boost等
	纹理图集（texture）,精灵表(sprite sheet) 把许多小图片组合到一张大图里面，减少内存使用。生成的文件为plist，使用zwoptex，texturepacker制作。精灵帧缓存SpriteFrameCache
	基本架构：sceneManager，welcomeLayer，MenuLayer，SoundLayer，SelectLayer，GameLayer，ControlLayer，网络工具类，常量类，数据类
	服务器端：数据类：临时数据，固定数据

```


**网络编程：**
```
资源：
	网站：https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio.html

	https://www.gamedev.net/blogs/entry/2249317-a-guide-to-getting-started-with-boostasio/?pg=2

    	https://www.boost.org/doc/libs/1_70_0/doc/html/boost_asio/examples/cpp11_examples.html（chat那个例子比较符合我们要做的）
	
	https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/Chapter1.html

	https://www.codeproject.com/Articles/1264257/Socket-Programming-in-Cplusplus-using-boost-asio-T
	
	学院给的pdf里的优秀案例中第二个泡泡堂项目也是用boost，可以阅读源码学习
	
笔记：
	  	用Nuget管理额外的库，如boost等,安装的是boost vc141而不是第一个boost，第一个相当于只有头文件（最好安装1.69那个）
		同步就是指一个进程在执行某个请求的时候，若该请求需要一段时间才能返回信息，那么这个进程将会一直等待下去，直到收到返回信息才继续执行下去；异步是指进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态。当有消息返回时系统会通知进程进行处理，这样可以提高执行的效率。而我们平时经常讨论的同步问题多发生在多线程环境中的数据共享问题。即当多个线程需要访问同一个资源时，它们需要以某种顺序来确保该资源在某一特定时刻只能被一个线程所访问，如果使用异步，程序的运行结果将不可预料。因此，在这种情况下，就必须对数据进行同步，即限制只能有一个进程访问资源，其他线程必须等待。 
		网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式Socket是发动机，提供了网络通信的能力。 
		网络由下往上分为:物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。 　　通过初步的了解，我知道IP协议对应于网络层，TCP协议对应于传输层，而HTTP协议对应于应用层，三者从本质上来说没有可比性,socket则是对TCP/IP协议的封装和应用(程序员层面上)。也可以说，TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。关于TCP/IP和HTTP协议的关系，网络有一段比较容易理解的介绍：我们在传输数据时，可以只使用(传输层)TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容。如果想要使传输的数据有意义，则必须使用到应用层协议。应用层协议有很多，比如HTTP、FTP、TELNET等，也可以自己定义应用层协议。WEB使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP做传输层协议将它发到网络上。”而我们平时说的最多的socket是什么呢，实际上socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口(API)。通过Socket，我们才能使用TCP/IP协议。实际上，Socket跟TCP/IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、listen、connect、accept、send、read和write等等。 　　网络有一段关于socket和TCP/IP协议关系的说法比较容易理解:”TCP/IP只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如win32编程接口一样， 　　TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口。” 
		你的程序中需要至少定义一个io_service对象：boost::asio::io_service io_service。io_service表示程序到操作系统I/O服务的“连接”。为执行I/O操作，还需要一个I/O对象（通常需要使用io_service构造），如一个TCP套接字：boost::asio::ip::tcp::socket socket(io_service)
		关于Proactor和Reactor模式主要的区别简单归结可以做如下比喻：Reactor：孩子该吃饭了，您可以去厨房拿菜做饭给孩子吃了。Proactor：孩子该吃饭了，按您的吩咐把饭菜做给孩子吃了，孩子已经吃完饭了。
		简单来说也就是Reactor模式关注就绪事件，比如孩子该吃饭了，具体要怎么做（去做饭给孩子吃）是你需要具体实施的；而Proactor关注完成事件，比如孩子该吃饭了，你事先通知保姆做什么饭，喂给孩子吃之后再通知我。
		Proactor采用异步IO, 在Proactor中实现读：
		o	处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。
		o	事件分离器等待操作完成事件
		o	在分离器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分离器读操作完成。
		o	事件分离器呼唤处理器。
		o	事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分离器。
		对某个IO事件的事件通知(即告诉某个模块，这个IO操作可以进行或已经完成), 当回调handler时，表示IO操作已经完成
		线程安全是多线程编程时的计算机程序代码中的一个概念。在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。类型等 io_context提供了更强的保证，即同时使用单个对象是安全的
		strand被定义为事件处理程序的严格顺序调用（即没有并发调用）。使用strands允许在多线程程序中执行代码，而无需显式锁定（例如使用互斥锁）。
		异步方式：向系统说一声要做什么，然后就可以做其它事去了。如果系统完成了操作， 系统就会通过我之前给它的回调对象来通知我。异步方式的函数或方法名称前面都有“async_” 前缀，函数参数里会要求放一个回调函数（或仿函数）。异步操作执行 后不管有没有完成都会立即返回，这时可以做一些其它事，直到回调函数（或仿函数）被调用，说明异步操作已经完成。在ASIO中很多回调函数都只接受一个boost::system::error_code参数，在实际使用时肯定是不够的，所以一般 使用仿函数携带一堆相关数据作为回调，或者使用boost::bind来绑定一堆数据。另外要注意的是，只有io_service类的run()方法运行之后回调对象才会被调用，否则即使系统已经完成了异步操作也不会有任 务动作。
		 std::enable_shared_from_this 能让一个对象（假设其名为 t ，且已被一个 std::shared_ptr 对象 pt 管理）安全地生成其他额外的 std::shared_ptr 实例（假设名为 pt1, pt2, ... ） ，它们与 pt 共享对象 t 的所有权。

```




